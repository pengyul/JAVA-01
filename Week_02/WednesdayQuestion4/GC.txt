不同GC总结：
串行GC：
    包括Serial和SerialOld，新生代采用复制算法，老年代采用标记-清除-整理算法。
    GC过程采用单线程，并且会STW，因此会暂停比较长的时间，根据GCLogAnalysis测试结果，
    堆内存1g情况下，平均每次GC暂停50ms左右，但是吞吐量还可以，每秒能生成12000个左右
    的对象，适合单核cpu，SerialOld也是CMS的后备方案。

并行GC：
   ParNew，Parallel Scavenge是新生代收集器，采用复制算法，Parallel Old采用
   标记-清除-整理算法。ParNew是Serial的并行版本，一般与CMS配合使用，CPU多核情况下，
   比Serial要好一些。Parallel Scavenge与Parallel Old配合，GC采用多线程，并且
   会STW，GC线程不存在与应用线程进行切换，因此吞吐量很高，也被称为吞吐量优先的收集器，
   根据GCLogAnalysis测试结果，堆内存1g情况下，平均每次GC暂停20ms左右，每秒能生成
   13000个左右的对象。适用于后台计算，不需要太多交互的任务，是Java8的默认收集器。
   Parallel Scavenge还可以设置自适应参数，可以不用手工指定-Xmn，Eden与Survivor的比例等。

CMS GC：
    一款致力于获取最短停顿时间为目标的收集器，采用标记-清除算法，作用于老年代，只有在
    初始标记和最终标记时STW，耗时较长的并发标记和并发清除阶段都是与应用线程一起运行，
    因此停顿时间较短，用户体验不错。但是由于并发时，会存在线程上下文切换，因此吞吐量不如
    并行GC。根据GCLogAnalysis测试结果，堆内存1g情况下，平均每次GC暂停1ms左右，每秒能
    生成13000个左右的对象，吞吐量跟并行GC差不多，看来理论和实际还是有差别啊。个人觉得
    跟环境、生成对象的随机性、测试时间有关，如果时间长一点，多测试几次，还是并行GC吞吐量会大。
    CMS适用于低延迟的系统，另外并行GC采取标记-清除算法，会产生较多的内存碎片，因此隔一段时间
    就会进行一次FullGC来整理内存，整理过程中不可并发，耗时也会较长。

G1 GC：
    G1 GC的目标是将垃圾回收的时间变得可预期且可配置，虽然也是低延迟的GC，但是不在划分年轻代
    和老年代，整个堆内存被分为很多个区域，每个小块可动态调整，会在Eden、Survivor、Old区之间
    切换，这样的话，每次GC时，不需要收集整个堆，而是采取增量的方式，只处理一部分块，使得GC时间
    可配置成为可能。G1 GC在并发时会估算每个区域存活对象的数量，垃圾回收时优先选择回收价值最大的
    区域，这也是G1名字的由来，Garbage-First。
    由于G1的设计，所以适用与年轻代和老年代，从整体上看采用标记-整理算法，但从局部看，在两个区域
    之间采用复制算法，整个GC过程跟CMS类似，适用于内存比较大的场景，是java9之后的默认的回收器。
    根据GCLogAnalysis测试结果，堆内存1g情况下，每秒能生成13000个左右的对象，每次停顿时间大概在
    1-2ms，停顿时间较短。
